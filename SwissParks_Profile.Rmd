
---
title: "Analysis of Swiss National Parks with Flickr data"
author: "Daniela Marino"
date: "5/2/2022"
output: 
  html_document: default
  
---

*Notes:*
  *Data: 2020-11-03_Switzerland_upto_2018-11-31, Switzerland_2018-12-01_2020-11-03.*
  *Pre-processing: After gathering the data, the two datasets were merged and it was cleaned the duplicates and empty values, specially for dates*


*PACKAGES*
```{r echo=TRUE}
#PACKAGES
#install.packages("tidyverse")
#install.packages("magrittr")
#install.packages("dplyr")
#install.packages("readxl")
#install.packages("here")
#install.packages("skimr")
#install.packages("kableExtra")
#install.packages("knitr")
#install.packages(magrittr)
#install.packages(lubridate)
#install.packages("stringr")
#install.packages("tibbletime")
#install.packages("ggmosaic")
#install.packages("scales")
```

```{r include=FALSE}
#Libraries
library(tidyverse)
library(magrittr)
library(dplyr)
library(readxl)
library(here)
library(skimr)
library(kableExtra)
library(knitr)
library(magrittr)
library(lubridate)
library(ggplot2)
library(stringr)
library(tibbletime)
library(ggmosaic)
library(scales)
```

### DATA LOADING
```{r echo=TRUE}
#Data source
flickr <- read_xlsx(here("Flickr_Data.xlsx"), col_types = c("numeric", "text", "numeric", 
        "numeric", "text", "date", "numeric", 
        "text", "numeric", "text", "text", 
        "text", "text", "text", "text", "text", 
        "text"))# explore data

summary(flickr)
```

```{r include=TRUE}
options(dplyr.summarise.inform = FALSE)
```

### FILTERING

#### a. Only pictures taken after 2004 (inclusive)

```{r echo=TRUE}
# using subset function

flickr_04 <- as_tbl_time(flickr, index = DATE)

flickr_04 <- filter(flickr_04, DATE >= as.Date("2004-01-01"))

summary(flickr_04)

```

#### b. Only pictures that are in categories of land cover that are natural

```{r echo=TRUE}

flickr_04nat <- filter(flickr_04, USE!=100, USE!=120, USE!=140, USE!=160)

summary(flickr_04nat)
```

## INTRODUCTION

```{r echo=TRUE}
#Option 1 = Application of the filter of the use, only natural land cover
  
db <- flickr_04nat

ddbb <- db
  
#Option 2 = No application of the filter of the use, all land cover types

#ddbb <- flickr_04


#Option 3 = Using all dataset with no filters (after 2004 and land cover)

#ddbb <- flickr

```

*a. Number of visitors each Swiss National Parks, according the land cover, *
   *NA values refers to users or land cover category that doesn't exist  in the park*
```{r echo=TRUE}
landcover <- flickr_04 %>%
  group_by(PARK, USE, USER)%>%
  summarise(land_user = n())

  #Counting the number of users per park in each season
landcover <- landcover %>%
  group_by(PARK, USE) %>%
  summarise(land = n())

lu<- pivot_wider(landcover, names_from = USE, values_from = land)
landcover_park <- as.data.frame(lu)

  #Rename of the codes (numbers) with the names of the days

    #Land cover categories that are reduced
names(landcover_park)[names(landcover_park)=="100"] <- "Building area"
names(landcover_park)[names(landcover_park)=="120"] <- "Traffic and transportation surface"
names(landcover_park)[names(landcover_park)=="140"] <- "Special settlement areas"
names(landcover_park)[names(landcover_park)=="160"] <- "Recreation and green spaces"

    #Land cover categories that are considered for the analysis
names(landcover_park)[names(landcover_park)=="200"] <- "Fruit growing, viticulture, horticulture"
names(landcover_park)[names(landcover_park)=="220"] <- "Arable and Forage Cultivation"
names(landcover_park)[names(landcover_park)=="240"] <- "Alpine farming"
names(landcover_park)[names(landcover_park)=="300"] <- "Forest"
names(landcover_park)[names(landcover_park)=="400"] <- "Lakes and rivers"
names(landcover_park)[names(landcover_park)=="420"] <- "Unproductives"

  #Display of the table with a better format
kbl(landcover_park)%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

*b. Area (km2) of national parks*
```{r echo=TRUE}
area <- ddbb %>%
  group_by(PARK, km2) %>%
  summarise(flickr_feature = n())

  #Counting the total area of parks
area <- area %>%
  group_by(PARK) %>%
  summarise(km = round(sum(km2),2))

#The total area of parks:
area %>%
  summarize(area = sum(km))#km2

summary(area)
```

*c. Count of pictures in the parks*
```{r echo=TRUE}
photos <- ddbb %>%
  group_by(PARK) %>%
  summarise(photo = n()) %>%
  mutate(ratio_photos= round((photo / sum(photo))*100, 3)) %>% 
  arrange(desc(ratio_photos))

#The total number of pictures is:
ddbb %>%
  summarize(count =  n())#pictures

summary(photos)
```

*d. Count of Users in the parks*
```{r echo=TRUE}
users_flickr <- ddbb %>%
  group_by(PARK, USER) %>%
  summarise(user_photos =  n())
  #Counting the total area of parks
users_flickr <- users_flickr %>%
  group_by(PARK) %>%
  summarise(user = n())%>%
  mutate(ratio_users= round((user / sum(user))*100, 3)) %>% 
  arrange(desc(ratio_users))

#The total area of parks:
users_flickr %>%
  summarize(users = sum(user))#users

summary(users_flickr)
```
 
*d. Statistic of area (km2), users and photos for each Swiss National Parks:*
*NOTE: THESE VALUES ONLY CONSIDER THE NATURAL LAND COVER  (the dismissed categories are: Building area", "Traffic and transportation surface", "Special settlement areas", "Recreation and green spaces"*
```{r echo=TRUE}
general <- data.frame("Parks"= area$PARK, "km"= area$km, "Photos"= photos$photo, "Photos_per"= photos$ratio_photos, "Photos_km"=round((photos$photo/area$km),2),"Users"=users_flickr$user, "Users_per"=users_flickr$ratio_users, "Users_km"=round((users_flickr$user/area$km),2))

kbl(general)%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")

write.csv(general,"C:\\Users\\dmarinoc\\Documents\\GitHub\\Flickr_SwissParks\\General.csv", row.names = FALSE)
```
## 1. YEARLY VISITOR IN THE PARKS
```{r echo=TRUE}

ddbb$DATE <- as.Date(ddbb$DATE)
ddbb$YEAR <- format(ddbb$DATE, format="%Y")

#Calculation of statistics per year
year_photo <- ddbb %>%
  group_by(PARK, YEAR, USER)%>%
  summarise(photo_yearly = n())

yearly_counts <- year_photo %>%
  group_by(PARK, YEAR)%>%
  summarise(VISITS = n())
            
ggplot(data = yearly_counts, aes(x = YEAR, y = VISITS, group = 1)) +
    geom_line() +
    facet_wrap(vars(PARK), labeller = label_wrap_gen(width=24))+
    theme_bw()+
    theme(axis.text.x = element_text(colour = "grey20", size = 7, angle = 90, hjust = 0.5, vjust = 0.5),
          axis.text.y = element_text(colour = "grey20", size = 7),
          strip.text = element_text(face = "italic"),
          text = element_text(size = 12))

```

## 2. PARK USERS PER SEASON
*Number of users per season in each Swiss National Parks*

```{r echo=TRUE}
#Creating season column

 #create dates variable for your column that contains dates 
dates <- ddbb$DATE
#get the month of the date, create new column called month
ddbb$month<-(month(dates, label=TRUE))

ddbb$SEASON <- ifelse(ddbb$month %in% c('May','Jun','Jul'), "SUMMER",
                    ifelse (ddbb$month %in% c('Aug','Sep','Oct'), "AUTUMN",
                            ifelse (ddbb$month %in% c('Nove','Dec','Jan'), 
                                    "WINTER", "SPRING")))

#Calculation of statistics per Season
season <- ddbb %>%
  group_by(PARK, SEASON, USER)%>%
  summarise(visit_season = n())

  #Counting the number of users per park in each season
season <- season %>%
  group_by(PARK, SEASON) %>%
  summarise(season_users = n())

sp<- pivot_wider(season, names_from = SEASON, values_from = season_users)
season_park <- data.frame(sp)

  #Display of the table with a better format
kbl(season_park)%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")


  #Stacked normalized horizontal bar graph
season_park %>% pivot_longer(-PARK) %>%
  ggplot(aes(x = factor(PARK), y = value, fill = name, group = name))+
  geom_bar(stat='identity', color='white', position='fill')+
  scale_y_continuous(labels = scales::percent)+
  scale_fill_manual(values=c("#ed7c31", "#00b04f", "#ffbf00","#00b0f0"))+
  theme(legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        plot.title = element_text(hjust=0.5))+
  coord_flip() +
  xlab('Swiss National Parks') + ylab('% visitors') +
  labs( fill = "SEASONS")+
  ggtitle('Proportion of visitors per Season')

```

## 3. PARK VISITORS PER DAY OF THE WEEK
*Number of visitors per day in each Swiss National Parks*
```{r echo=TRUE}

ddbb$DAY <- weekdays(as.Date(ddbb$DATE))
ddbb$DAY <- factor(ddbb$DAY, levels = c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"))
#
photoUser_day <- ddbb %>%
  group_by(PARK, DAY, USER)%>%
  summarise(photo_day = n())

  #Counting the number of users per park in each season
daily <- photoUser_day %>%
  group_by(PARK, DAY) %>%
  summarise(visit_day = n())

sd<- pivot_wider(daily, names_from = DAY, values_from = visit_day)

daily_park <- as.data.frame(sd)

  #Display of the table with a better format
kbl(daily_park)%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

*Bar plot of visitors per day in the Parks*
```{r setup, include=TRUE}

# Chunk options
knitr::opts_chunk$set(
 fig.width = 10,
 fig.asp = 0.9,
 out.width = "100%"
)
```

```{r theme_ggplot2, echo = FALSE}
theme_base <- function(base_size = 14) {
  theme_bw(base_size = base_size) %+replace%
    theme(
        legend.position = 'top',
        legend.background = element_rect(fill = "transparent", colour = NA),
        legend.key = element_rect(fill = "transparent", colour = NA),
        plot.title = element_text(hjust=0.5, face = 'bold'),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(color = "black", arrow = arrow(length = unit(0.1, "lines"), type = "closed")),
        axis.text.x = element_text(angle = 90, vjust = 0.15, hjust=0.15, size = 10),
        axis.text.y = element_text(size = 10),
        strip.background = element_rect(fill = "#17252D", color = "#17252D"),
        strip.text = element_text(size = rel(0.5), face = "bold", color = "white", margin = margin(5,0,5,0))
        )
}

```

```{r echo=TRUE}
  #Horizontal bar chart of daily number of visitors per Park

daily_park %>% 
  pivot_longer(-PARK)  %>% 
ggplot(aes(x = factor(PARK), y = value, fill = name, group = name)) +
  geom_bar(position="dodge", stat="identity", color='white', width = 0.8)+
  scale_fill_manual(values=c("#2980b9", "#27ae60", "#f39c12","#d35400", "#5dade2","#2ecc71","#76d7c4"))+
  theme_base()+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 22))+
  xlab('Swiss National Parks') + ylab('Number of visitors') +
  labs( fill = "DAY")+
  ggtitle('Daily number of visitors')

```
*Mosaic plot of visitors per day in the Parks (Two test)*
```{r echo=TRUE}
  #GRAPH OF MOSAIC PLOT OF PARKS AND DAYS

#TEST 1: 
ggplot(data = photoUser_day) +
  geom_mosaic(aes(x=product(DAY, PARK), fill = DAY)) +
  scale_fill_manual(values=c("#27ae60","#2ecc71","#76d7c4", "#5dade2", "#2980b9", "#f39c12","#d35400"))+
  labs(y = "DAYS", title=" offset = 0.01") +
  theme(legend.position = "none",
        axis.text.y=element_text(size = 8),
        axis.ticks.y=element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 8))

#TEST 2
count <- table(photoUser_day$DAY,  photoUser_day$PARK)

mosaicplot(count, main = "Daily visitor of the Swiss National Parks",
           sub = "Product of visitors",
           xlab = "Days",
           ylab = "Parks",
           las = 1,
           border = "black",
           off = 10,
           shade = TRUE)

#TEST 3
ggplot(daily, aes(x = PARK, y = visit_day, color = DAY)) +
  geom_point() +
  labs(x = "Days", y = "Visits") +
  scale_color_manual(name = "Days:", values=c("#27ae60","#2ecc71","#76d7c4", "#5dade2", "#2980b9", "#f39c12","#d35400")) +
  theme(legend.title = element_text(size = 14, face = 2),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 8))


```

## 5. USERS PROFILES
*Analysis of users according the canton origin, visited park, and time span between the first and the last picture *

### 5.a. Canton of origin
```{r echo=FALSE}
canton<- ddbb %>%
  group_by(CANTON, USER)%>%
  summarise(canton_user = n())

co<- pivot_wider(canton, names_from = CANTON, values_from = canton_user)
canton_users <- as.data.frame(co)
canton_users[is.na(canton_users)] = 0
canton_users <- canton_users %>% mutate_if(is.numeric, ~1 * (. > 0))
canton_users$Total_Canton = rowSums(canton_users[,c(2:13)])
canton_users <- canton_users[order(canton_users$Total_Canton, decreasing = FALSE),]

write.csv(canton_users,"C:\\Users\\dmarinoc\\Documents\\GitHub\\Flickr_SwissParks\\Canton_Users.csv", row.names = FALSE)

ggplot(canton_users, aes(x=Total_Canton))+
  geom_histogram(binwidth=1 ,colour="black", fill="white")+
  geom_vline(aes(xintercept=mean(Total_Canton)), color="blue", linetype="dashed", size=1)+
  labs(title="Histogram of Cantons by users ",x="Number of visited Cantons", y = "Count of users")+
  scale_x_continuous(breaks = seq(0, 12, 1))+
  scale_y_continuous(breaks = seq(0, 2500, 100))

#Heatmap

coul <- colorRampPalette(c("beige", "green"))(2)

rownames(canton_users) <- canton_users[,1]
canton_users[,1]<- NULL
canton_users[,13]<- NULL
data <-as.matrix(canton_users)

heatmap(data, Colv = NA, Rowv = NA, scale = "column", col = coul, main = "Heatmap of User per Canton")


```
*Origin of user per Canton*
```{r echo=FALSE}
kbl(canton_users[1:20,])%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

### 5.b. Park of origin
```{r echo=FALSE}
park <- ddbb %>%
  group_by(PARK, USER)%>%
  summarise(park_user = n())

po<- pivot_wider(park, names_from = PARK, values_from = park_user)
park_users <- as.data.frame(po)
park_users[is.na(park_users)] = 0
park_users <- park_users %>% mutate_if(is.numeric, ~1 * (. > 0))
park_users$Total_Park = rowSums(park_users[,c(2:21)])
park_users <- park_users[order(park_users$Total_Park, decreasing = FALSE),]

write.csv(park_users,"C:\\Users\\dmarinoc\\Documents\\GitHub\\Flickr_SwissParks\\Park_Users.csv", row.names = FALSE)

ggplot(park_users, aes(x=Total_Park))+
  geom_histogram(binwidth=1 ,colour="black", fill="white")+
  geom_vline(aes(xintercept=mean(Total_Park)), color="blue", linetype="dashed", size=1)+
  labs(title="Histogram of Parks by users ",x="Number of visited Parks", y = "Count of users")+
  scale_x_continuous(breaks = seq(0, 20, 1))+
  scale_y_continuous(breaks = seq(0, 2500, 100))

#Heatmap

coul <- colorRampPalette(c("beige", "blue"))(2)

rownames(park_users) <- park_users[,1]
park_users[,1]<- NULL
park_users[,21]<- NULL
data <-as.matrix(park_users)

heatmap(data, Colv = NA, Rowv = NA, scale = "column", col = coul, main = "Heatmap of User per Park")

```

*Origin of user per Park*
```{r echo=FALSE}
 kbl(park_users[1:20,])%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

### 5.c. Time span
```{r echo=FALSE}
user <- ddbb %>%
  group_by(USER)%>%
  summarise(photos = n())

user <- as.data.frame(user)

dt <- ddbb %>%
  group_by(USER, DATE)%>%
  summarise(photos = n())%>%
  mutate(DATE=as.Date(DATE))

dt1 <- dt %>%
    group_by(USER) %>%
    arrange(DATE) %>%
    slice(1L)

first <- as.data.frame(dt1)
names(first)[names(first)=="DATE"] <- "start"
dt2 <- dt %>%
    group_by(USER) %>%
     arrange(desc(DATE)) %>%
    slice(1L)

last <- as.data.frame(dt)
names(last)[names(last)=="DATE"] <- "end"
dt <- merge(last, first, by="USER")
dur <- dt %>%
  mutate(
    days = end - start,
    seconds    = as.numeric(difftime(end, start)) / 365.25,
    years = round((start %--% end) / years(1)),
    between = end %--% start 
  )

time_user <-  merge(user, dur, by="USER", all=T)
time_user <- subset(time_user, select=-c(photos.x,photos.y))
time_user <- time_user[order(time_user$seconds, decreasing = TRUE),]

ggplot(time_user, aes(x=years))+
  geom_histogram(binwidth=1 ,colour="black", fill="white")+
  geom_vline(aes(xintercept=mean(years)), color="blue", linetype="dashed", size=1)+
  labs(title="Histogram of time between first and last picture by users ",x="time span in years", y = "Count of users")+
  scale_x_continuous(breaks = seq(0, 20, 1))+
  scale_y_continuous(breaks = seq(0, 5000, 500))

write.csv(time_user,"C:\\Users\\dmarinoc\\Documents\\GitHub\\Flickr_SwissParks\\Time_Users.csv", row.names = FALSE)
```

*User timespend of taken pictures*
```{r echo=FALSE}
kbl(time_user[1:20,])%>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

*Photos taken in the same date in the same position*
```{r echo=FALSE}
  #5.d. Frequency of visits
photo_date_place <- ddbb %>%
  group_by(USER, DATE, lat)%>%
  summarise(photo1day_sameplace = n())

ggplot(photo_date_place, aes(x=photo1day_sameplace))+
  geom_histogram(binwidth=1 ,colour="black", fill="white")+
  geom_vline(aes(xintercept=mean(photo1day_sameplace)), color="blue", linetype="dashed", size=1)+
  labs(title="Number of photos in a day, in the same place ",x="No. pictures in the same place in a day", y = "No. users")+
  xlim(c(0,80))+ ylim(c(0,500))

user_date_place <- photo_date_place %>%
  group_by(USER, DATE)%>%
  summarise(moves1day_users= n())

ggplot(user_date_place, aes(x=moves1day_users))+
  geom_histogram(binwidth=1 ,colour="black", fill="white")+
  geom_vline(aes(xintercept=mean(moves1day_users)), color="blue", linetype="dashed", size=1)+
  labs(title="Number of moves in a day", x="No. moves in a day", y = "No. users")+
  xlim(c(0,100))+ ylim(c(0,2000))
```

*Presence of visitors in a day, in different positions*
```{r echo=FALSE}
user_daily_visits <- user_date_place %>%
  group_by(USER)%>%
  summarise(user_day_stay = n())

ggplot(user_daily_visits, aes(x=user_day_stay))+
  geom_histogram(binwidth=1 ,colour="black", fill="white")+
  geom_vline(aes(xintercept=mean(user_day_stay)), color="blue", linetype="dashed", size=1)+
  labs(title="Timespend in a place (possible in different visits)", x="No. days spend", y = "No. users")+
  xlim(c(0,100))+ ylim(c(0,600))
```

## Textual Analysis

```{r include=FALSE}
# Install Packages
#install.packages("tm") # for text mining
#install.packages("SnowballC") # for text stemming
#install.packages("wordcloud") # word-cloud generator 
#install.packages("RColorBrewer") # color palettes
#install.packages("quanteda")
#install.packages("igraph")
#install.packages("reshape2")

#Load libraries
library(tm)
library(SnowballC)
library(wordcloud)
library(RColorBrewer)
library(tidyverse)
library(tidytext)
library(quanteda)
library(igraph)
library(reshape2)
```

```{r echo=TRUE}

set.seed(42)

base <- data.frame(ddbb$photo_id, ddbb$USER, ddbb$PARK,  ddbb$TAGS)
names(base)[names(base) == "ddbb.PARK"] <- "doc_id"
names(base)[names(base) == "ddbb.TAGS"] <- "text"
names(base)[names(base) == "ddbb.USER"] <- "author"
names(base)[names(base) == "ddbb.photo_id"] <- "origin"
base$text <- tolower(base$text) # Lowercase
base$text <- gsub("[[:digit:]]", " ", base$text) # Remove numbers
base$text <- gsub("\\s+", " ", str_trim(base$text)) # Remove extra whitespaces
base$text <- gsub("(\\-¨“„)", " ", base$text) # Remove extra symbols
base$text <- gsub("(?!\\.)[[:punct:]]", " ", base$text, perl=TRUE) #remove punctuation
base <- base[-which(is.na(base$text)),] #dropping row without TAGS
base_source=DataframeSource(base)
base_corpus=VCorpus(base_source)
base_corpus_clean <- tm_map(base_corpus, removeWords, stopwords("english"))
base_corpus_root <- tm_map(base_corpus_clean,stemDocument) #find to root of the words 
wordcloud(base_corpus_root, 
          min.freq = 50,
          max.words = 100,
          random.order = FALSE,
          random.color = FALSE,
          colors = brewer.pal(8, "Dark2"))

#myStopwords <- setdiff(myStopwords, c("d", "e")) 
#text_corpus_clean <- tm_map(base_corpus_clean, removeWords, myStopwords)

dtm <- DocumentTermMatrix(base_corpus_root, control= list(wordLengths=c(3, 8)))
head(sort(slam::col_sums(dtm), decreasing = TRUE), n=10)
```

```{r echo=TRUE}

Heaps_plot(dtm)

Zipf_plot(dtm)

```

*Bipartite network of parks and tags*
```{r echo=FALSE}
dtm_df <- reshape2::melt(as.matrix(dtm))
# remove 0 values and order the data.frame
dtm_df <- dtm_df[dtm_df$value > 2, ]
dtm_df <- dtm_df[order(dtm_df$value, decreasing = TRUE), ]
```

```{r echo=FALSE}
set.seed(42)
g <- graph.data.frame(dtm_df, directed = FALSE)
#bg <-bipartite.mapping(g)
plot(g)
